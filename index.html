<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alleyway Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center; /* 垂直居中 */
            align-items: center; /* 水平居中 */
            height: 100vh; /* 占滿整個視窗高度 */
            margin: 0;
            background-color: #000; /* 背景顏色 */
        }
        canvas {
            border: 1px solid black;
            max-width: 100%; /* 最大寬度為 100% */
            height: auto; /* 高度自動調整 */
        }
        button {
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #0095DD;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #007bb5;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="300"></canvas>
<button id="startButton">Start Game</button>
<button id="restartButton">Restart Game</button>

<script>
// JavaScript 代碼開始
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const restartButton = document.getElementById('restartButton');
const startButton = document.getElementById('startButton');

// 設置遊戲變量
const brickWidth = 20; // 磚塊寬度
const brickHeight = 10; // 磚塊高度
const brickPadding = 5; // 磚塊間距
const brickOffsetTop = 30; // 磚塊上邊距
const brickOffsetLeft = 30; // 磚塊左邊距

let bricks = [];
let score = 0;
let lives = 3;
let gameOver = false;

function createBricks() {
    bricks = [];
    const rows = [
        "M   M  1   1",
        "MM MM  1  1 1",
        "M M M  1 1 1 1",
        "M   M  1 1   1",
    ];
    for (let r = 0; r < rows.length; r++) {
        const row = [];
        for (let c = 0; c < rows[r].length; c++) {
            if (rows[r][c] !== " ") {
                row.push({
                    x: c * (brickWidth + brickPadding) + brickOffsetLeft,
                    y: r * (brickHeight + brickPadding) + brickOffsetTop,
                    visible: true,
                });
            }
        }
        bricks.push(row);
    }
}

let paddleWidth = 100;
let paddleHeight = 10;
let paddleX = (canvas.width - paddleWidth) / 2;
let ballRadius = 10;
let ballX, ballY;

// 設置球的速度
let dx = 6; // 水平速度
let dy = -6; // 垂直速度

function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
}

function drawBall() {
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
}

function drawBricks() {
    bricks.forEach((row) => {
        row.forEach((brick) => {
            if (brick.visible) {
                ctx.beginPath();
                ctx.rect(brick.x, brick.y, brickWidth, brickHeight);
                ctx.fillStyle = '#0095DD';
                ctx.fill();
                ctx.closePath();
            }
        });
    });
}

function collisionDetection() {
    bricks.forEach((row) => {
        row.forEach((brick) => {
            if (brick.visible) {
                if (
                    ballX + ballRadius > brick.x && 
                    ballX - ballRadius < brick.x + brickWidth && 
                    ballY + ballRadius > brick.y && 
                    ballY - ballRadius < brick.y + brickHeight
                ) {
                    dy = -dy; // 改變球的方向
                    brick.visible = false; // 隱藏磚塊
                    score++; // 增加分數

                    if (ballY + ballRadius > brick.y && ballY - ballRadius < brick.y + brickHeight) {
                        if (ballY < brick.y + (brickHeight / 2)) { 
                            ballY = brick.y - ballRadius;
                        } else { 
                            ballY = brick.y + brickHeight + ballRadius;
                        }
                    }
                }
            }
        });
    });
    
    if (bricks.every(row => row.every(brick => !brick.visible))) {
        gameOver = true; 
    }
}

function drawScore() {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText('Score: ' + score, 8, 20);
    
    ctx.fillText('Lives: ' + lives, canvas.width - 65, 20);
}

function drawBoundary() {
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.stroke();
    ctx.closePath();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBoundary(); 
    drawBricks(); 
    collisionDetection(); 

    drawPaddle(); 
    drawBall(); 
    drawScore(); 
    
    ballX += dx; 
    ballY += dy;

    if (ballX + dx > canvas.width - ballRadius || ballX + dx < ballRadius) {
        dx = -dx; 
    }
    
    if (ballY + dy < ballRadius || (ballY + dy > canvas.height - ballRadius && ballX > paddleX && ballX < paddleX + paddleWidth)) {
        dy = -dy; 
    } else if (ballY + dy > canvas.height - ballRadius) {
        lives--; 
        if (!lives) {
            gameOver = true; 
        } else { 
            resetBall(); 
        }
    }

    if (!gameOver) {
        requestAnimationFrame(draw); 
    } else {
        ctx.font = '30px Arial';
        ctx.fillStyle = 'red'; 
        
        if (score === bricks.flat().length) { 
            ctx.fillText("識啲野", canvas.width / 2 - 70, canvas.height / 2);
        } else { 
            ctx.fillText("無用", canvas.width / 2 - 70, canvas.height / 2);
        }

        restartButton.style.display = 'block'; 
    }
}

function resetBall() {
   // 將球的位置設置在球拍上方，避免一開始就輸掉遊戲
   ballX = canvas.width / 2;
   ballY = canvas.height - paddleHeight - ballRadius - 5;

   dx = Math.random() > 0.5 ? dx : -dx; 
}

// 開始遊戲功能
function startGame() {
   startButton.style.display = 'none'; 

   gameOver = false; 
   score = 0; 
   lives = 3;

   createBricks(); 
   resetBall(); 

   draw(); 
}

// 添加鼠標移動事件處理程序
function mouseMoveHandler(e) {
   const rect = canvas.getBoundingClientRect(); // Get canvas bounds
   const relativeX = e.clientX - rect.left; // Calculate relative X position

   // Update paddle position based on mouse movement
   if (relativeX > 0 && relativeX < canvas.width) {
       paddleX = relativeX - paddleWidth / 2; // Center the paddle under the cursor
   }
}

// Add event listener for pointer movement
canvas.addEventListener('pointermove', mouseMoveHandler, false);

// 支持觸控屏控制（如手機）
canvas.addEventListener('touchmove', (e) => {
   e.preventDefault(); 

   const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;

   if (touchX >= paddleWidth / 2 && touchX <= canvas.width - paddleWidth / 2) { 
       paddleX = touchX - paddleWidth / 2; 
   } else if (touchX < paddleWidth / 2) { 
       paddleX=0 ;// 如果點擊在左側，將球拍移到最左側 
   } else { 
       paddleX=canvas.width-paddleWidth ;// 如果點擊在右側，將球拍移到最右側 
   }

   if (paddleX <0){ 
       paddleX=0 ;// 防止超出邊界 
   }else if(paddleX+paddleWidth>canvas.width){ 
       paddleX=canvas.width-paddleWidth ;// 防止超出邊界 
   }
});

function restartGame() {
   gameOver = false;
   
   score = 0;
   
   lives = 3; 
    
   createBricks(); 
    
   resetBall(); 

   restartButton.style.display = 'none'; 

   draw(); 
}

// 為重啟按鈕和開始按鈕添加事件監聽器
restartButton.addEventListener('click', restartGame);
startButton.addEventListener('click', startGame);

// 顯示開始按鈕以啟動遊戲流程
startButton.style.display = 'block';

</script>

</body>
</html>
