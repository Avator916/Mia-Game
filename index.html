<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alleyway Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center; /* 垂直居中 */
            align-items: center; /* 水平居中 */
            height: 100vh; /* 占滿整個視窗高度 */
            margin: 0;
            background-color: #000; /* 背景顏色 */
        }
        canvas {
            border: 1px solid black;
            max-width: 100%; /* 最大寬度為 100% */
            height: auto; /* 高度自動調整 */
        }
        button {
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #0095DD;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #007bb5;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="300"></canvas>
<button id="startButton">Start Game</button>
<button id="restartButton">Restart Game</button>

<script>
// JavaScript 代碼開始
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const restartButton = document.getElementById('restartButton');
const startButton = document.getElementById('startButton');

// 設置遊戲變量
const brickWidth = 20; // 磚塊寬度
const brickHeight = 10; // 磚塊高度
const brickPadding = 5; // 磚塊間距
const brickOffsetTop = 30; // 磚塊上邊距
const brickOffsetLeft = 30; // 磚塊左邊距

let bricks = [];
let score = 0;
let lives = 3;
let gameOver = false;

// 創建形狀為 "MIA" 的磚塊
function createBricks() {
    bricks = [];
    const rows = [
        "M   M  1   1",
        "MM MM  1  1 1",
        "M M M  1 1 1 1",
        "M   M  1 1   1",
    ];
    for (let r = 0; r < rows.length; r++) {
        const row = [];
        for (let c = 0; c < rows[r].length; c++) {
            if (rows[r][c] !== " ") {
                row.push({
                    x: c * (brickWidth + brickPadding) + brickOffsetLeft,
                    y: r * (brickHeight + brickPadding) + brickOffsetTop,
                    visible: true,
                });
            }
        }
        bricks.push(row);
    }
}

let paddleWidth = 100;
let paddleHeight = 10;
let paddleX = (canvas.width - paddleWidth) / 2;
let ballRadius = 10;
let ballX = canvas.width / 2;
let ballY = canvas.height - 30;

// 設置球的速度
let dx = 6; // 水平速度
let dy = -6; // 垂直速度

function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
}

function drawBall() {
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
}

function drawBricks() {
    bricks.forEach((row) => {
        row.forEach((brick) => {
            if (brick.visible) {
                ctx.beginPath();
                ctx.rect(brick.x, brick.y, brickWidth, brickHeight);
                ctx.fillStyle = '#0095DD';
                ctx.fill();
                ctx.closePath();
            }
        });
    });
}

function collisionDetection() {
    bricks.forEach((row) => {
        row.forEach((brick) => {
            if (brick.visible) {
                if (
                    ballX + ballRadius > brick.x && 
                    ballX - ballRadius < brick.x + brickWidth && 
                    ballY + ballRadius > brick.y && 
                    ballY - ballRadius < brick.y + brickHeight
                ) {
                    dy = -dy; // 改變球的方向
                    brick.visible = false; // 隱藏磚塊
                    score++; // 增加分數

                    // 確保球不會穿透磚塊，將球移到磚塊的邊緣
                    if (ballY + ballRadius > brick.y && ballY - ballRadius < brick.y + brickHeight) {
                        if (ballY < brick.y + (brickHeight / 2)) { // 球從上面碰撞
                            ballY = brick.y - ballRadius;
                        } else { // 球從下面碰撞
                            ballY = brick.y + brickHeight + ballRadius;
                        }
                    }
                }
            }
        });
    });
    
    // 檢查是否所有磚塊都被擊中
    if (bricks.every(row => row.every(brick => !brick.visible))) {
        gameOver = true; // 所有磚塊被擊中，遊戲結束
    }
}

function drawScore() {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText('Score: ' + score, 8, 20);
    
    ctx.fillText('Lives: ' + lives, canvas.width - 65, 20);
}

function drawBoundary() {
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.stroke();
    ctx.closePath();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBoundary(); // 繪製邊界
    drawBricks(); // 繪製磚塊
    collisionDetection(); // 碰撞檢測

    drawPaddle(); // 繪製球拍
    drawBall(); // 繪製球
    drawScore(); // 繪製分數
    
    ballX += dx; // 移動球
    ballY += dy;

    if (ballX + dx > canvas.width - ballRadius || ballX + dx < ballRadius) {
        dx = -dx; // 球與牆壁碰撞
    }
    
    if (ballY + dy < ballRadius || (ballY + dy > canvas.height - ballRadius && ballX > paddleX && ballX < paddleX + paddleWidth)) {
        dy = -dy; // 球與上方或球拍碰撞
    } else if (ballY + dy > canvas.height - ballRadius) {
        lives--; // 減少生命值
        if (!lives) {
            gameOver = true; // 遊戲結束
        } else { 
            resetBall(); // 重置球的位置
        }
    }

    if (!gameOver) {
        requestAnimationFrame(draw); // 繼續遊戲循環
    } else {
        ctx.font = '30px Arial';
        ctx.fillStyle = 'red'; // 設置字體顏色為紅色
        
        if (score === bricks.flat().length) { // 檢查是否擊中所有磚塊
            ctx.fillText("識啲野", canvas.width / 2 - 70, canvas.height / 2);
        } else { 
            ctx.fillText("無用", canvas.width / 2 - 70, canvas.height / 2);
        }

        restartButton.style.display = 'block'; // 顯示重啟按鈕
    }
}

function resetBall() {
    ballX = canvas.width / 2;
    ballY = canvas.height - 30;

    dx = Math.random() > 0.5 ? dx : -dx; // 隨機方向重置水平速度
}

// 開始遊戲功能
function startGame() {
   startButton.style.display = 'none'; // 隱藏開始按鈕

   gameOver = false; 
   score = 0; 
   lives = 3;

   createBricks(); 
   resetBall(); 

   draw(); // 開始遊戲循環
}

// 傾斜控制功能
window.addEventListener('deviceorientation', function(event) {
   const tiltLR = event.gamma; // 左右傾斜度

   const maxPaddleX = canvas.width - paddleWidth;

   if (tiltLR > 15 && paddleX < maxPaddleX) { 
       paddleX += dx * (tiltLR / window.innerWidth); // 向右移動球拍，根據傾斜程度調整速度
   } else if (tiltLR < -15 && paddleX > 0) { 
       paddleX -= dx * (-tiltLR / window.innerWidth); // 向左移動球拍，根據傾斜程度調整速度
   }
});

// 支持觸控屏控制（如手機）
canvas.addEventListener('touchmove', (e) => {
   e.preventDefault(); 

   const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;

   if (touchX >= paddleWidth / 2 && touchX <= canvas.width - paddleWidth / 2) { 
       paddleX = touchX - paddleWidth / 2; 
   } else if (touchX < paddleWidth / 2) { 
       paddleX=0 ;// 如果點擊在左側，將球拍移到最左側 
   } else { 
       paddleX=canvas.width-paddleWidth ;// 如果點擊在右側，將球拍移到最右側 
   }

   if (paddleX <0){ 
       paddleX=0 ;// 防止超出邊界 
   }else if(paddleX+paddleWidth>canvas.width){ 
       paddleX=canvas.width-paddleWidth ;// 防止超出邊界 
   }
});

function restartGame() {
    gameOver = false;
    
    score = 0;
    
    lives = 3; 
    
    createBricks(); 
    
    resetBall(); 

    restartButton.style.display = 'none'; 

    draw(); 
}

// 為重啟按鈕和開始按鈕添加事件監聽器
restartButton.addEventListener('click', restartGame);
startButton.addEventListener('click', startGame);

// 顯示開始按鈕以啟動遊戲流程
startButton.style.display = 'block';

</script>

</body>
</html>
