<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alleyway Game</title>
    <style>
        body {
            display: flex;
            justify-content: center; /* 垂直居中 */
            align-items: center; /* 水平居中 */
            height: 100vh; /* 占滿整個視窗高度 */
            margin: 0;
            background-color: #000; /* 背景顏色 */
        }
        canvas {
            border: 1px solid black;
            max-width: 100%; /* 最大寬度為 100% */
            height: auto; /* 高度自動調整 */
        }
        #restartButton {
            display: none; /* 初始隱藏按鈕 */
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #0095DD;
            color: white;
            border: none;
            cursor: pointer;
        }
        #restartButton:hover {
            background-color: #007bb5;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="300"></canvas>
<button id="restartButton">Restart Game</button>

<script>
// JavaScript 代碼開始
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const restartButton = document.getElementById('restartButton');

// 設置遊戲變量
const brickWidth = 20; // 磚塊寬度
const brickHeight = 10; // 磚塊高度
const brickPadding = 5; // 磚塊間距
const brickOffsetTop = 30; // 磚塊上邊距
const brickOffsetLeft = 30; // 磚塊左邊距

let bricks = [];
let score = 0;
let lives = 3;
let gameOver = false;

// 創建形狀為 "MIA" 的磚塊
function createBricks() {
    bricks = [];
    const rows = [
        "M   M  1   1",
        "MM MM  1  1 1",
        "M M M  1 1 1 1",
        "M   M  1 1   1",
    ];
    for (let r = 0; r < rows.length; r++) {
        const row = [];
        for (let c = 0; c < rows[r].length; c++) {
            if (rows[r][c] !== " ") {
                row.push({
                    x: c * (brickWidth + brickPadding) + brickOffsetLeft,
                    y: r * (brickHeight + brickPadding) + brickOffsetTop,
                    visible: true,
                });
            }
        }
        bricks.push(row);
    }
}

createBricks();

let paddleWidth = 100;
let paddleHeight = 10;
let paddleX = (canvas.width - paddleWidth) / 2;
let ballRadius = 10;
let ballX = canvas.width / 2;
let ballY = canvas.height - 30;

// 設置球的速度
let dx = 6; // 水平速度
let dy = -6; // 垂直速度

function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
}

function drawBall() {
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
}

function drawBricks() {
    bricks.forEach((row) => {
        row.forEach((brick) => {
            if (brick.visible) {
                ctx.beginPath();
                ctx.rect(brick.x, brick.y, brickWidth, brickHeight);
                ctx.fillStyle = '#0095DD';
                ctx.fill();
                ctx.closePath();
            }
        });
    });
}

function collisionDetection() {
    bricks.forEach((row) => {
        row.forEach((brick) => {
            if (brick.visible) {
                if (
                    ballX + ballRadius > brick.x && 
                    ballX - ballRadius < brick.x + brickWidth && 
                    ballY + ballRadius > brick.y && 
                    ballY - ballRadius < brick.y + brickHeight
                ) {
                    dy = -dy; // 改變球的方向
                    brick.visible = false; // 隱藏磚塊
                    score++; // 增加分數

                    // 確保球不會穿透磚塊，將球移到磚塊的邊緣
                    if (ballY + ballRadius > brick.y && ballY - ballRadius < brick.y + brickHeight) {
                        if (ballY < brick.y + (brickHeight / 2)) { // 球從上面碰撞
                            ballY = brick.y - ballRadius;
                        } else { // 球從下面碰撞
                            ballY = brick.y + brickHeight + ballRadius;
                        }
                    }
                }
            }
        });
    });
    
    // 檢查是否所有磚塊都被擊中
    if (bricks.every(row => row.every(brick => !brick.visible))) {
        gameOver = true; // 所有磚塊被擊中，遊戲結束
    }
}

function drawScore() {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText('Score: ' + score, 8, 20);
    
    ctx.fillText('Lives: ' + lives, canvas.width - 65, 20);
}

function drawBoundary() {
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.stroke();
    ctx.closePath();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBoundary(); // 繪製邊界
    drawBricks(); // 繪製磚塊
    collisionDetection(); // 碰撞檢測

    drawPaddle(); // 繪製球拍
    drawBall(); // 繪製球
    drawScore(); // 繪製分數
    
    ballX += dx; // 移動球
    ballY += dy;

    if (ballX + dx > canvas.width - ballRadius || ballX + dx < ballRadius) {
        dx = -dx; // 球與牆壁碰撞
    }
    
    if (ballY + dy < ballRadius || (ballY + dy > canvas.height - ballRadius && ballX > paddleX && ballX < paddleX + paddleWidth)) {
        dy = -dy; // 球與上方或球拍碰撞
    } else if (ballY + dy > canvas.height - ballRadius) {
        lives--; // 減少生命值
        if (!lives) {
            gameOver = true; // 遊戲結束
        } else { 
            resetBall(); // 重置球的位置
        }
    }

    if (!gameOver) {
        requestAnimationFrame(draw); // 繼續遊戲循環
    } else {
        ctx.font = '30px Arial';
        ctx.fillStyle = 'red'; // 設置字體顏色為紅色
        
        if (score === bricks.flat().length) { // 檢查是否擊中所有磚塊
            ctx.fillText("識啲野", canvas.width / 2 - 70, canvas.height / 2);
        } else { 
            ctx.fillText("無用", canvas.width / 2 - 70, canvas.height / 2);
        }

        restartButton.style.display = 'block'; // 顯示重啟按鈕
    }
}

function resetBall() {
    ballX = canvas.width / 2;
    ballY = canvas.height - 30;

    dx = Math.random() > 0.5 ? dx : -dx; // 隨機方向重置水平速度
}

document.addEventListener('mousemove', (e) => {
    const mouseX = e.clientX - canvas.getBoundingClientRect().left; // 獲取滑鼠的 X 坐標
    
    if (mouseX >= paddleWidth / 2 && mouseX <= canvas.width - paddleWidth / 2) { 
        paddleX = mouseX - paddleWidth / 2; // 更新球拍位置以跟隨滑鼠移動
        
        if (paddleX < 0) { 
            paddleX = 0; 
        } else if (paddleX + paddleWidth > canvas.width) { 
            paddleX = canvas.width - paddleWidth; 
        }
    }
});

// 支持觸控屏控制（如手機）
canvas.addEventListener('touchmove', (e) => {
   e.preventDefault(); // 防止滾動頁面

   const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;

   if (touchX >= paddleWidth / 2 && touchX <= canvas.width - paddleWidth / 2) { 
       paddleX = touchX - paddleWidth / 2; 
   } else if (touchX < paddleWidth / 2) { 
       paddleX = touchWidth /2 ; // 如果點擊在左側，將球拍移到最左側 
   } else { 
       paddleX=canvas.width-paddleWidth/2 ;// 如果點擊在右側，將球拍移到最右側 
   }

   if (paddleX <0){ 
       paddleX=0 ;// 防止超出邊界 
   }else if(paddleX+paddleWidth>canvas.width){ 
       paddleX=canvas.width-paddleWidth ;// 防止超出邊界 
   }
});

function restartGame() {
    gameOver = false;
    
    score = 0;
    
    lives = 3; // 重置生命值
    
    createBricks(); // 重建磚塊
    
    resetBall(); // 重置球的位置

    restartButton.style.display = 'none'; // 隱藏重啟按鈕

    draw(); // 開始遊戲循環
}

// 為重啟按鈕添加事件監聽器
restartButton.addEventListener('click', restartGame);

createBricks(); // 創建磚塊
draw(); // 開始遊戲循環

</script>

</body>
</html>
